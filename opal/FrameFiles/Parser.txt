using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Text;
(. usings .)

(. namespace.start .)
public partial class Parser: IDisposable
{
	private readonly ILogger _logger;
	private readonly Scanner _scanner;
	private readonly LRStack _stack;
	private bool _hasErrors;
		
	public Parser(ILogger logger, Scanner scanner)
	{
		_logger = logger;
		_scanner = scanner;
		_stack = new LRStack();
		Init();
	}

	public Parser(Scanner scanner)
		: this(new ConsoleLogger(scanner.FilePath), scanner) {}

	public Parser(ILogger logger, string filePath)
		: this(logger, Scanner.FromFile(filePath)) {}

	public Parser(string filePath)
		: this(Scanner.FromFile(filePath))
	{
	}

	public static Parser FromString(string text)
	{
		var scanner = new Scanner(text);
		return new Parser(scanner);
	}

	public void Dispose()
	{
		_scanner.Dispose();
	}

	public object Root { get; private set; }

	partial void Init();

	public bool Parse()
	{
		var token = NextToken();
		var errorState = 0U;
		var suppressError = 0;

		while (true)
		{
            if (suppressError > 0) --suppressError;
			
			var state = _stack.PeekState();
			var actionType = GetAction(state, (uint) token.State, out var result);

			switch (actionType)
			{
				case ActionType.Error:
                    _hasErrors = true;
                    if (!TryRecover(ref token, (suppressError > 0)))
                        return false;
                    if (token.State == 0)
                    {
                        if (errorState == state)
                            return false;
                        else
                            errorState = state;
                    }
                    suppressError = 2;
	                break;

				case ActionType.Reduce:
					var rule = result;
					var reducedState = Reduce(rule);
					if (rule == 0)
					{
						Root = _stack.PopValue();
						return !_hasErrors;
					}
					if (GetAction(reducedState, _stack.PeekState(), out result) == ActionType.Error)
						goto case ActionType.Error;
					_stack.Replace((uint)result);
					break;

				case ActionType.Shift:
					_stack.Shift(result, token);
					token = NextToken();
					break;
			}
		}
	}

    private Token NextToken()
    {
        while (true)
        {
            var token = _scanner.NextToken();
            if (token.State >= 0)
                return token;
            _logger.LogError(token, "syntax error - {0}", token.Value);
            _hasErrors = true;
        }
    }

	private uint Reduce(uint rule)
	{
		uint state = 0;

		switch (rule)
		{
(. productions .)
		}
		return state;
	}

	private enum ActionType { Shift, Reduce, Error }

	private ActionType GetAction(uint state, uint token, out uint arg)
	{
		var action = _actions[state, token];
		ActionType actionType;
		if (action == -1)
		{
			actionType = ActionType.Error;
		}
		else if (action >= 0)
		{
			actionType = ActionType.Shift;
		}
		else
		{
			actionType = ActionType.Reduce;
			action = -2 - action;
		}
		arg = (uint)action;
		return actionType;
	}

	#region Actions Table
(. actions .)
	#endregion
	#region Symbols
(. parser.symbols .)
	#endregion
	
    /// <summary>
    /// Called by reduction for an invalid, extra token
    /// </summary>
    /// <param name="t">Invalid token</param>
    /// <param name="result">Value to return</param>
    /// <returns>Result that allows parser to correctly</returns>
    private object InvalidToken(Token t, object result)
    {
        _logger.LogError(t, "unexpected token {0}", t.Value);
        return result;
    }

    private bool TryRecover(ref Token token, bool suppress)
    {
        var isOk = false;

        if (token.State != 0)
            _logger.LogError(token, "unexpected token '{0}'", token.Value);
        else
            _logger.LogError(token, "unexpected token [EOF]");

        while (true)
        {
            for (var i = 0; _stack.GetState(i, out var state); i++)
            {
                if (_actions[state, token.State] != -1)
                {
                    _stack.Pop(i);
                    return true;
                }
            }
            if (token.State == 0)
                break;
            token = NextToken();
        }
        return isOk;
    }

	#region LRStack
	[DebuggerDisplay("Count = {_count}"), DebuggerTypeProxy(typeof(LRStackProxy))]
	private class LRStack
	{
		private Rec[] _array = new Rec[4];
		private int _items;
		private int _count = 1;
	
		public LRStack SetItems(int value)
		{
			_items = value;
			return this;
		}
	
		public object this[int offset]
		{
			get
			{
				if (_count < offset || offset < 0)
					throw new InvalidOperationException(string.Format("Unable to retrieve {0} items", offset));
				return _array[_count - _items + offset].Value;
			}
		}
	
		public uint Reduce(uint state, object value)
		{
			var oldState = _array[_count - _items - 1].State;
			for (var i = _items - 1; i > 0; i--)
				_array[_count - i].Value = null;
			_array[_count - _items] = new Rec(state, value);
			_count = _count - _items + 1;
			return oldState;
		}

        public uint Push(uint state, object value)
        {
            var oldState = _array[_count - 1].State;
            Shift(state, value);
            return oldState;
        }

        public void Replace(uint state)
		{
			_array[_count - 1].State = state;
		}
	
		public void Shift(uint state, object value)
		{
            if (_count == _array.Length)
            {
                var array = new Rec[_array.Length == 0 ? 4 : 2 * _array.Length];
                Array.Copy(_array, 0, array, 0, _count);
                _array = array;
            }
            _array[_count++] = new Rec(state, value);
		}
	
		public object PopValue()
		{
			return _array[--_count].Value;
		}

		public bool GetState(int index, out uint state)
        {
            index++;
            var isOk = _count > index;
            state = isOk ? _array[_count - index].State : 0;
            return isOk;
        }

        public void Pop(int items)
        {
            for (var i = items - 1; i > 0; i--)
                _array[_count - i].Value = null;
            _count -= items;
        }
	
		public uint PeekState()
		{
			return _array[_count - 1].State;
		}
	
        [DebuggerDisplay("{State,2}: {Value}")]
		struct Rec
		{
			public Rec(uint state, object value)
			{
				State = state;
				Value = value;
			}
			public uint State;
			public object Value;
		}

        sealed class LRStackProxy
        {
            private readonly LRStack _stack;
            public LRStackProxy(LRStack stack)
            {
                _stack = stack;
            }

            [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
            public Rec[] Items
            {
                get
                {
                    var result = new Rec[_stack._count];
                    for (var i = 0; i < _stack._count; i++)
                        result[i] = _stack._array[_stack._count - i - 1];
                    return result;
                }
            }
        }
	}
	#endregion
}

(. scanner .)
public class TokenStates
{
(. scanner.states .)};

public class Token: Segment
{
	public int State;
	public string Value;

	public Token() {}
		
	public Token(int line, int column, int ch)
		: base(new Position(line, column, ch)) {}

	public Token Set(int state, string value, int ln, int col, int ch)
	{
		State = state;
		Value = value;
		End = new Position(ln, col, ch);
		return this;
	}

    public static implicit operator string(Token t)
    {
        return t.Value;
    }

	public override string ToString()
	{
		return string.Format("({0},{1}): '{2}', state = {3}", Start.Ln, Start.Col, Value, State);
	}
}

///<summary>Location of a character within a file</summary>
public struct Position: IEquatable<Position>
{
	public readonly int Ln;
	public readonly int Col;
	public readonly int Ch;

	public Position(int ln, int col, int ch)
	{
		Ln = ln;
		Col = col;
		Ch = ch;
	}

	#region Methods

	public override int GetHashCode()
	{
		return Ch.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		return Equals((Position)obj);
	}

	public bool Equals(Position other)
	{
		return Ch == other.Ch;
	}

	public override string ToString()
	{
		return string.Format("Ln {0}, Col {1}, Ch {2}", Ln, Col, Ch);
	}

	public static bool operator ==(Position left, Position right)
	{
		return left.Ch == right.Ch;
	}

	public static bool operator !=(Position left, Position right)
	{
		return left.Ch != right.Ch;
	}
	#endregion
}

///<summary>Segment location in a file</summary>
public class Segment
{
	public Position Start;
	public Position End;

	public Segment() {}

	public Segment(Segment cpy)
	{
		if (cpy != null)
		{
			Start = cpy.Start;
			End = cpy.End;
		}
	}

	public Segment(Position start)
	{
		Start = start;
		End = start;
	}

	public Segment(Position start, Position end)
	{
		Start = start;
		End = end;
	}

	#region Properties
		
	public bool IsEmpty
	{
		get { return End == Start; }
	}

	public int Beg
	{
		get { return Start.Ch; }
	}

	public int Length
	{
		get { return End.Ch - Start.Ch; }
	}
		
	#endregion

	public void CopyFrom(Segment segment)
	{
		if (segment != null)
		{
			Start = segment.Start;
			End = segment.End;
		}
	}
}

/// <summary>
/// Buffer between text/file object and scanner
/// </summary>
public interface IBuffer: IDisposable
{
    /// <summary>
    /// Returns the index within the buffer
    /// </summary>
    int Position { get; set; }

    /// <summary>
    /// Returns the next character, moves the position one forward
    /// </summary>
    /// <returns></returns>
    int Read();

    /// <summary>
    /// Examines the next character in the stream, leaves position at the same place
    /// </summary>
    /// <returns></returns>
    int Peek();

    /// <summary>
    /// Returns string from beg to end
    /// </summary>
    /// <param name="beg"></param>
    /// <param name="end"></param>
    /// <returns></returns>
    string GetString(int beg, int end);
}

public class FileBuffer : IBuffer, IDisposable
{
    private readonly StreamReader _reader;
    private readonly StringBuilder _builder;
    private int _filePos;
    private int _remaining;
    private readonly long _fileLength;

    public FileBuffer(string filePath)
        : this(new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read))
    {
    }

    public FileBuffer(Stream stream)
    {
        _fileLength = stream.Length;
        _reader = new StreamReader(stream);
        _builder = new StringBuilder();
    }

    public int Position
    {
        get { return _filePos - _remaining; }
        set { _remaining = _filePos - value; }
    }

    public void Dispose()
    {
        _reader.Dispose();
    }

    public string GetString(int beg, int end)
    {
        var length = end - beg;
        var pos = _filePos - _remaining;
        var start = pos - beg;
        var shift = _builder.Length - start;
        var result = _builder.ToString(shift, length);
        _builder.Remove(shift, length);
        return result;
    }

    public int Peek()
    {
        int result;
        if (_remaining > 0)
        {
            result = _builder[_builder.Length - _remaining];
        }
        else if (_filePos < _fileLength)
        {
            result = _reader.Read();
            _builder.Append((char)result);
            _filePos++;
            _remaining++;
        }
        else
        {
            result = -1;
        }
        return result;
    }

    public int Read()
    {
        int result;
        if (_remaining > 0)
        {
            result = _builder[_builder.Length - _remaining--];
        }
        else if (_filePos < _fileLength)
        {
            result = _reader.Read();
            _builder.Append((char)result);
            _filePos++;
        }
        else
        {
            result = -1;
        }
        return result;
    }
}

public class StringBuffer: IBuffer
{
    private readonly string _text;

    public StringBuffer(string text)
    {
        _text = text;
    }

	public void Dispose() {}

    public int Position { get; set;}

    public int Read()
    {
        return (Position < _text.Length) ? _text[Position++] : -1;
    }

    public int Peek()
    {
        return (Position < _text.Length) ? _text[Position] : -1;
    }

    public string GetString(int start, int end)
    {
        return _text.Substring(start, end - start);
    }
}

#region Logger

public enum Importance
{
	High = 0,
	Normal = 1,
	Low = 2
}

public interface ILogger
{
	void LogError(string message, params object[] messageArgs);
	void LogError(Segment segment, string message, params object[] messageArgs);
	void LogWarning(string message, params object[] messageArgs);
	void LogWarning(Segment segment, string message, params object[] messageArgs);
	void LogMessage(Importance importance, string message, params object[] messageArgs);
	void LogMessage(Importance importance, Segment segment, string message, params object[] messageArgs);
}

public class ConsoleLogger : ILogger
{
    private readonly string _file;
    private readonly ConsoleColor _oldColor;

    public ConsoleLogger(string file)
    {
        _file = file;
        _oldColor = Console.ForegroundColor;
    }

    public void LogError(string message, params object[] messageArgs)
    {	Log(ConsoleColor.Red, message, messageArgs); }

    public void LogError(Segment segment, string message, params object[] messageArgs)
    {	Log(ConsoleColor.Red, segment, message, messageArgs); }

    public void LogMessage(string message, params object[] messageArgs)
    {	LogMessage(Importance.Low, message, messageArgs); }

    public void LogMessage(Importance importance, string message, params object[] messageArgs)
    {	
        Log(ToColor(importance), message, messageArgs);
    }

	public void LogMessage(Importance importance, Segment segment, string message, params object[] messageArgs)
	{
		Log(ToColor(importance), segment, message, messageArgs);
	}

    public void LogWarning(Segment segment, string message, params object[] messageArgs)
    {	Log(ConsoleColor.Yellow, segment, message, messageArgs); }

    public void LogWarning(string message, params object[] messageArgs)
    {	Log(ConsoleColor.Yellow, message, messageArgs); }

    public void Log(ConsoleColor color, Segment segment, string message, params object[] messageArgs)
    {
        var builder = new StringBuilder();
        if (!string.IsNullOrEmpty(_file))
            builder.Append(_file);
        if (segment.Start.Ln > 0)
        {
            builder.Append('(').Append(segment.Start.Ln);
            if (segment.Start.Col > 0)
            {
                builder.Append(',').Append(segment.Start.Col);
                if (segment.End.Ln > 0)
                    builder.Append(',').Append(segment.End.Ln).Append(',').Append(segment.End.Col);
            }
            builder.Append(')');
        }
        if (builder.Length > 0)
            builder.Append(":\t");
        if (messageArgs == null || messageArgs.Length == 0)
            builder.Append(message);
        else
            builder.AppendFormat(message, messageArgs);
        Log(color, builder.ToString());
    }

    public void Log(ConsoleColor color, string message, params object[] messageArgs)
    {
        if (messageArgs == null || messageArgs.Length == 0)
            Log(color, message);
        else
            Log(color, string.Format(message, messageArgs));
    }

    public void Log(ConsoleColor color, string message)
    {
        Console.ForegroundColor = color;
        Console.WriteLine(message);
        Console.ForegroundColor = _oldColor;
    }

	private static ConsoleColor ToColor(Importance importance)
	{
        ConsoleColor color;
        switch (importance)
        {
            case Importance.High:	color = ConsoleColor.White; break;
            case Importance.Normal:	color = ConsoleColor.Gray; break;
            default:				color = ConsoleColor.DarkGray; break;
        }
		return color;
	}
}
#endregion
(. namespace.end .)