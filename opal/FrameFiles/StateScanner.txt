public class Scanner: IDisposable
{
    public const int Eof = -1;

    private readonly IBuffer _buffer;
    private int _ch;
	private int _line;
	private int _column;

    private static readonly int[] _charToClass;
    private static readonly int[,] _states;

	static Scanner()
	{
        _charToClass = new int[char.MaxValue + 1];
        using (var outStream = new MemoryStream())
		{
            Decompress(_charToClassCompressed, outStream);
            outStream.Seek(0, SeekOrigin.Begin);
            for (var i = 0; i < _charToClass.Length; i++)
                _charToClass[i] = (. dfa.class.read .)(outStream) + 1;
                
            outStream.SetLength(0);
			Decompress(_compressedStates, outStream);
            outStream.Seek(0, SeekOrigin.Begin);

			var maxClasses = (. dfa.maxClass .) + 1;
			var maxStates = (. dfa.maxStates .);
            _states = new int[maxStates + 1, maxClasses];

            for (var i = 0; i < maxStates; i++)
                for (var j = 0; j < maxClasses; j++)
                    _states[i, j] = (. dfa.states.read .)(outStream);

            for (int i = 1; i < maxClasses; i++)
            {
                if (_states[0, i] == 0)
                {
                    _states[0, i] = maxStates;
                    _states[maxStates, i] = maxStates;
                }
            }
			_states[maxStates, 0] = -1;
		}
	}


    public Scanner(string source, int line = 1, int column = 0)
		: this(new StringBuffer(source), line, column)
    {
    }

	public Scanner(IBuffer buffer, int line = 1, int column = 0)
	{
		_buffer = buffer;
		_line = line;
		_column = column;
        NextChar();
	}

	public static Scanner FromFile(string filePath, int line = 1, int column = 0)
	{
		return new Scanner(new FileBuffer(filePath), line, column);
	}

	public void Dispose()
	{
		_buffer.Dispose();
	}

	public string FilePath { get; private set; }

    /// <summary>Skips ingore-tokens</summary>
    public Token NextToken()
    {
        Token token;
        do
        {
            token = RawNextToken();
        } while (token.State < TokenStates.SyntaxError);

        return token;
    }
        
    /// <summary>Returns next token</summary>
    public Token RawNextToken()
    {
        Token token;
        if (_ch == Eof)
        {
            token = new Token(_line, _column, _buffer.Position)
            {
                End = new Position(_line, _column, _buffer.Position)
            };
            return token;
        }
            
		var startPosition = _buffer.Position - 1;
        token = new Token(_line, _column, startPosition);

        var lastLine = _line;
        var lastColumn = _column;
        var lastAcceptingState = TokenStates.SyntaxError;
        var lastAcceptingPosition = -1;
        var stateIndex = 0;

        while (true)
        {
            var nextState = GetNextState(stateIndex);
            if (nextState <= 0)
            {
                if (lastAcceptingState == TokenStates.SyntaxError)
                    lastAcceptingPosition = _buffer.Position - 1;

                var value = _buffer.GetString(startPosition, lastAcceptingPosition);
                token.Set(lastAcceptingState, value, lastLine, lastColumn, lastAcceptingPosition - 1);
				if (_buffer.Position > lastAcceptingPosition + 1)
				{
					_buffer.Position = lastAcceptingPosition;
					_line = lastLine;
					_column = lastColumn;
					NextChar();
				}
                return token;
            }
            else
            {
                var acceptingState = _states[nextState, 0];
                if (acceptingState != 0)
                {
                    lastAcceptingState = acceptingState;
                    lastAcceptingPosition = _buffer.Position;
                    lastLine = _line;
                    lastColumn = _column;
                }
            }
            stateIndex = nextState;
            NextChar();
        }
    }

    public int GetNextState(int stateIndex)
    {
        int nextState;
        if (_ch >= 0)
        {
            var cls = _charToClass[_ch];
            nextState = _states[stateIndex, cls];
        }
        else
        {
            nextState = 0;
        }
        return nextState;
    }

    /// <summary>
    /// Retrieves the next character, adjusting position information
    /// </summary>
    public void NextChar()
    {
        _ch = _buffer.Read();
        if (_ch == '\n')
        {
            ++_line;
            _column = 0;
        }
        //Normalize \r\n -> \n
        else if (_ch == '\r' && _buffer.Peek() == '\n')
        {
            _ch = _buffer.Read();
            ++_line;
            _column = 0;
        }
        else
        { 
            ++_column;
        }
    }

(. scanner.char.map .)
(. scanner.states .)

    private static void Decompress(byte[] data, Stream outStream)
    {
        using (var inStream = new MemoryStream(data))
        {
            var s = new GZipStream(inStream, CompressionMode.Decompress, false);
                s.CopyTo(outStream);
        }
    }

	#region Read Methods

    public static int Read8(Stream stream)
    {
        return (sbyte) stream.ReadByte();
    }

    public static int Read16(Stream stream)
    {
        var b1 = stream.ReadByte();
        var b2 = stream.ReadByte();
		return (short)(b1 | (b2 << 8));
    }

    public static int Read24(Stream stream)
    {
        var b1 = stream.ReadByte();
        var b2 = stream.ReadByte();
        var b3 = stream.ReadByte();
		return b1 | (b2 << 8) | (b3 << 16);
    }

    public static int Read32(Stream stream)
    {
        var b1 = stream.ReadByte();
        var b2 = stream.ReadByte();
        var b3 = stream.ReadByte();
        var b4 = stream.ReadByte();
		return b1 | (b2 << 8) | (b3 << 16) | (b4 << 24);
    }

	#endregion
}