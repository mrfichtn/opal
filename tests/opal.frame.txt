using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Text;
(. usings .)

(. namespace.start .)
public partial class Parser: IDisposable
{
	private readonly ILogger _logger;
	private readonly Scanner _scanner;
	private LRStack _stack;
	private bool _hasErrors;
	private int items;
		
	public Parser(ILogger logger, Scanner scanner)
	{
		_logger = logger;
		_scanner = scanner;
		_stack = LRStack.Root;
		Init();
	}

	public Parser(Scanner scanner)
		: this(new ConsoleLogger(scanner.FilePath), scanner) {}

	public Parser(ILogger logger, string filePath)
		: this(logger, Scanner.FromFile(filePath)) {}

	public Parser(string filePath)
		: this(Scanner.FromFile(filePath))
	{
	}

	public static Parser FromString(string text)
	{
		var scanner = new Scanner(text);
		return new Parser(scanner);
	}

	public void Dispose() => _scanner.Dispose();

	public object Root { get; private set; }

	partial void Init();

	public bool Parse()
	{
		var token = NextToken();
		var errorState = 0U;
		var suppressError = 0;

		while (true)
		{
            if (suppressError > 0) --suppressError;
			
			var state = _stack.State;
			var actionType = GetAction(state, (uint) token.State, out var result);

			switch (actionType)
			{
				case ActionType.Error:
                    _hasErrors = true;
                    if (!TryRecover(ref token, (suppressError > 0)))
                        return false;
                    if (token.State == 0)
                    {
                        if (errorState == state)
                            return false;
                        else
                            errorState = state;
                    }
                    suppressError = 2;
	                break;

				case ActionType.Reduce:
					var rule = result;
					var reducedState = Reduce(rule);
					if (rule == 0)
					{
						Root = _stack.Value;
						return !_hasErrors;
					}
					if (GetAction(reducedState, _stack.State, out result) == ActionType.Error)
						goto case ActionType.Error;
					_stack = _stack.Replace((uint)result);
					break;

				case ActionType.Shift:
					_stack = _stack.Shift(result, token);
					token = NextToken();
					break;
			}
		}
	}

    private Token NextToken()
    {
        while (true)
        {
            var token = _scanner.NextToken();
            if (token.State >= 0)
                return token;
            _logger.LogError(token, "syntax error - {0}", token.Value);
            _hasErrors = true;
        }
    }

	private uint Reduce(uint rule)
	{
		uint state = 0;

		switch (rule)
		{
(. productions .)
		}
		return state;
	}

	private enum ActionType { Shift, Reduce, Error }

	private ActionType GetAction(uint state, uint token, out uint arg)
	{
		var action = _actions[state, token];
		ActionType actionType;
		if (action == -1)
		{
			actionType = ActionType.Error;
		}
		else if (action >= 0)
		{
			actionType = ActionType.Shift;
		}
		else
		{
			actionType = ActionType.Reduce;
			action = -2 - action;
		}
		arg = (uint)action;
		return actionType;
	}

	#region Actions Table
(. actions .)
	#endregion
	#region Symbols
(. parser.symbols .)
	#endregion
	
	private bool TryRecover(ref Token token, bool suppress)
	{
	    var isOk = false;

		if (token.State != 0)
		{
			_logger.LogError(token, "Unexpected token '{0}'", token.Value);
			_logger.LogError("[{0,4}]   {1}", token.Start.Ln, _scanner.Line(token.Start.Ln));
			_logger.LogError("        {0}{1}", 
				new string(' ', token.Start.Col),
				new string('^', token.Length));
		}
		else
		{
			_logger.LogError(token, "unexpected token [EOF]");
		}
	
	    while (true)
	    {
	        for (var i = 0; _stack.GetState(i, out var state); i++)
	        {
	            if (_actions[state, token.State] != -1)
	            {
	                _stack = _stack.Pop(1);
	                return true;
	            }
	        }
	        if (token.State == 0)
	            break;
	        token = NextToken();
	    }
	    return isOk;
	}

	private T At<T>(int index) => (T)At(index);

	private object At(int index) => _stack[items - index - 1].Value;	
		
	private uint Reduce(uint state, object value)
    {
		var oldStack = _stack[items];
		var newState = oldStack.State;
		_stack = new LRStack(state, value, oldStack);
		return newState;
    }

	private uint Push(uint state, object value)
    {
		var oldState = _stack.State;
		_stack = new LRStack(state, value, _stack);
		return oldState;
	}
}

(. scanner .)
public class TokenStates
{
(. scanner.states .)};

(. namespace.end .)