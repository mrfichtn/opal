using Opal.Nfa;
using Opal.ParseTree;

namespace Opal;

Options
	//frame					= "opal.parser.frame"
	no_action				= "null"
	//nfa					= "opal.nfa.txt"
	//scanner				= "switch"
	scanner					= "state"
	emit_token_states		= false
	no.token				= true
	no.buffer				= true
	no.logger				= true
	no.lrstack				= true
	syntax.error.tokens     = true

Characters
	char_class_ctrl 		= [\[\]\^\\]
	char_class_char 		= !char_class_ctrl - [\r\n\t]
	char_class_esc          = char_class_ctrl + ["'0abfnrtv]
	
	esc                     = [\\]
	letter					= [a-zA-Z]
	non_zero				= [1-9]
	digit					= [0-9]
	hex_digit				= [a-fA-F]+digit
	cr						= [\r]
	lf 						= [\n]
	tab						= [\t]
	quote 					= ["]
	single_quote            = [']
	string_char				= [^"\r\n\\]
	string_esc_char         = ["'\\0abfnrtv]
	space_char				= [ ]
	other_white_space_char 	= tab+cr+lf
	all_space               = space_char+other_white_space_char
	start_id_char			= [_@]+letter
	id_char 				= start_id_char+digit
	not_lf                  = ![\n]
	non_asterisk            = ![*]
	non_slash               = ![/]
	
Tokens
	identifier = start_id_char id_char*;
	char_class = '[' '^'? (char_class_char | (esc char_class_esc))* ']';
	string = quote 
		(
			string_char | 
			(
				esc 
				string_esc_char |
				('u' hex_digit{4}) |
				('x' hex_digit{1,4})
			)
		)* quote;
 
	char_string = single_quote 
		(
			string_char | 
			(	esc 
				( 
					string_esc_char |
					('u' hex_digit{4}) |
					('x' hex_digit{1,4})
				)
			)
		) single_quote;
  
	integer = '0' | (non_zero digit*);
	arg = '$' ('0' | (non_zero digit*));
	Space<ignore> = all_space+;
	Comment<ignore> = "//" not_lf*;
	multi_line_comment<ignore> = "/*" 
	(
		non_asterisk
		|
		(
			'*'
			non_slash
		)
	)* "*/";
	
Productions language
	language = 
		using_section 
		namespace_section	
		option_section 
		characters_section 
		token_section 
		production_section
		conflict_section										{ new Language(
																	$0: UsingList,
																	$1: Identifier, 
																	$2: OptionList,
																	$3: CharacterList,
																	$4: TokenList, 
																	$5: ProductionSection, 
																	$6: ConflictList); }

	using_section =												{ new UsingList(); }
				  | using_section using_decl					{ UsingList.Add($0, $1); }
	
	using_decl = "using" Identifier ';'							{ new Using($1); }

	namespace_section   = 
						| "namespace" Identifier ';'			{ $1; }

	option_section	= 
					| "Options" option_list						{ $1; }

	option_list = option										{ new OptionList($0); }
				| option_list option		                    { OptionList.Add($0, $1); }

	option	=	Identifier '=' option_expr                      { new Option($0, $2); }

	option_expr													< IConstant >
				= string_literal								
				| Boolean
				;


	characters_section	=										{ new CharacterList(); }
							| "Characters" character_list       { $1; }

	character_list	=  character    							{ new CharacterList($0); }
					|  character_list character     			{ CharacterList.Add($0, $1); }

	character       = identifier '=' char_class_concat			{ new Character($0, $2: IMatch); }

	char_class_concat											<CharacterExpr>
					  = char_class_unary
				      | char_class_concat '+' char_class_unary	{ new CharacterUnionExpr($0, $2); }
				      | char_class_concat '-' char_class_unary	{ new CharacterDiffExpr($0, $2); }

	char_class_unary 											<CharacterExpr>	
					 = char_class_primary 
					 | '!' char_class_unary						{ new CharacterInvertExpr($0, $1); }

	char_class_primary											<CharacterExpr>
						= CharClass								{ new CharacterClass($0); }
						| Identifier							{ new CharacterSymbol($0); }
						| Char									{ new CharacterChar($0); }

	token_section	=											
					| "Tokens" token_list						{ $1; }

	token_list  = token											{ new TokenList($0); }
				| token_list token								{ TokenList.Add($0, $1); }

	token		= identifier token_attr '=' token_expr ';'		{ new TokenDeclaration($0, $1, $3); }

	token_attr	= 
				| '<' identifier '>'							{ $1; }

	token_expr													<TokenExpr>
				= token_quantifier
				| token_expr '|' token_quantifier				{ new UnionTokenExpr($0, $2); }
				| token_expr token_quantifier					{ new ConcatTokenExpr($0, $1); }

	token_quantifier											<TokenExpr>
				= token_primary
				| token_primary '+'								{ new PlusClosureExpr($0); }
				| token_primary '*'								{ new StarClosureExpr($0); }
				| token_primary '?'								{ new QuestionClosureExpr($0); }
				| token_primary '{' Integer '}'					{ new QuantifierTokenExpr($0, $2); }
				| token_primary '{' Integer ',' Integer '}'		{ new RangeTokenExpr($0, $2, $4); }

	token_primary												<TokenExpr>
					= identifier								{ new SymbolTokenExpr($0); }
					| Char										{ new CharTokenExpr($0); }
					| CharClass									{ new CharClassTokenExpr($0); }
					| string_literal							{ new StringLiteralTokenExpr($0); }
					| '(' token_expr ')'						{ $1; }

	production_section	= "Productions" identifier prod_list	{ new ProductionSection($1, $2); }

	prod_list	=												{ new ProductionList(); }
				| prod_list production							{ ProductionList.Add($0, $1); }

	production	
		= identifier production_attr_option '=' prod_def_list	{ new Production($0, $1, $3); }

	production_attr_option	= production_attr
							| ;
	
	production_attr	= '<' Identifier func_opt '>'				{ new ProductionAttr($1, $2); }
		
	func_opt	=	
				| '(' func_opt_arg_type ')'						{ new FuncOption($0, $1: Identifier); }
	
	func_opt_arg_type =	| Identifier;

	prod_def_list	
		=  prod_def_start prod_expr_list ';'					{ ProdDefList.Add($0, $1); }
		|  prod_def_start prod_def								{ ProdDefList.Add($0, $1); }

	prod_def_start 
		=														{ new ProdDefList(); }
		| prod_def_start prod_expr_list '|'						{ ProdDefList.Add($0, $1); }
		| prod_def_start prod_def '|'							{ ProdDefList.Add($0, $1); }

	prod_def 
		= prod_expr_list prod_action optional_semicolon			{ new ProdDef($0, $1: ActionExpr); }

	optional_semicolon = | ';';

	prod_expr_list =											{ new ProductionExprList(); }
				   | prod_expr_list prod_expr					{ ProductionExprList.Add($0, $1: ProductionExpr); }

	prod_expr	= prod_expr_quantifier production_attr_option	{ ProductionExpr.SetAttributes($0: ProductionExpr, $1: ProductionAttr); }

	prod_expr_quantifier = prod_expr_primary						
						 | prod_expr_primary '?'				{ new QuestionProdExpr($0, $1); }
						 ;

	prod_expr_primary	= identifier							{ new SymbolProd($0); }
						| string_literal						{ new StringTokenProd($0: StringConst); }
						| Char									{ new CharTokenProd($0: CharConst); }

	prod_action =  '{' action_stmt  '}'							{ $1; }

	action_stmt = 												{ new ActionNullExpr(); }
				| action_expr ";"								{ $0; }

	action_expr = "new" type '(' action_args ')'				{ new ActionNewExpr($1:Identifier, $3); }
				| Identifier '(' action_args ')'				{ new ActionFuncExpr($0, $2); }
				| action_primary_expr							{ $0; }

	action_args =												{ new ActionArgs(); }
				| action_expr									{ new ActionArgs($0: ActionExpr); }
				| action_args ',' action_expr					{ ActionArgs.Add($0, $2: ActionExpr); }

	action_primary_expr = arg action_cast						{ new ActionArg($0, $1: Identifier); }
						| Identifier							{ new ActionMember($0); }
						| Integer                               { new ActionIntConstant($0); }
						| string_literal                                { new ActionStringConstant($0: StringConst); }
						| Boolean                               { new ActionBoolConstant($0); }

	action_cast = 
				| ':' Identifier								{ $1; }

	type	=	Identifier										{ $0:Identifier; }
			|	Identifier '<' generic_args '>'					{ Identifier.MakeType($0:Identifier, $2:GenericArgs); }
			

	generic_args	=	type									{ new GenericArgs($0:Identifier); }
					|	generic_args ',' type					{ GenericArgs.Add($0, $2:Identifier); }
				
				
	conflict_section	=
						| "Conflicts" conflict_list
						;

	conflict_list		=										{ new ConflictList(); }
						| conflict_list conflict				{ ConflictList.Add($0, $1); }
						

	conflict			= Identifier ',' Identifier ':' Identifier Identifier ';'
																{ new Conflict($0, $2, $4, $5); }

	Identifier	=	identifier 									{ new Identifier($0); }
				|	Identifier '.' identifier					{ Identifier.Add($0, $2); }

	CharClass = char_class										{ new CharClass($0); }
	Char = char_string											{ new EscChar($0); }
	string_literal = regular_string_literal						{ $0; }
	regular_string_literal = string								{ new EscString($0); }
	Integer = integer											{ new DecInteger($0); }
	Boolean = "true"											{ new BoolConst($0, true); }
			| "false"                                           { new BoolConst($0, false); }
